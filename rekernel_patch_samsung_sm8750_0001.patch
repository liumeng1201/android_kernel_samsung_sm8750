diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 60af93c04..5076b0e5a 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -1585,3 +1585,5 @@ CONFIG_CORESIGHT_STM=m
 CONFIG_CORESIGHT_CPU_DEBUG=m
 CONFIG_CORESIGHT_CTI=m
 CONFIG_MEMTEST=y
+CONFIG_REKERNEL=y
+CONFIG_REKERNEL_NETWORK=n
diff --git a/drivers/Kconfig b/drivers/Kconfig
index efb66e25f..b86231b39 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -243,4 +243,6 @@ source "drivers/hte/Kconfig"
 
 source "drivers/cdx/Kconfig"
 
+
+source "drivers/rekernel/Kconfig"
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 3771823d2..e267d57a4 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -200,3 +200,4 @@ obj-$(CONFIG_CDX_BUS)		+= cdx/
 
 obj-$(CONFIG_S390)		+= s390/
 obj-$(CONFIG_UH)	+= uh/
+obj-$(CONFIG_REKERNEL) += rekernel/
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index f3ddbf2f9..93aea4d59 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -69,6 +69,9 @@
 #include <linux/ktime.h>
 
 #include <uapi/linux/sched/types.h>
+#ifdef CONFIG_REKERNEL
+#include <../rekernel/rekernel.h>
+#endif /* CONFIG_REKERNEL */
 #include <uapi/linux/android/binder.h>
 
 #include <linux/cacheflush.h>
@@ -2969,8 +2972,12 @@ static int binder_fixup_parent(struct list_head *pf_head,
 static bool binder_can_update_transaction(struct binder_transaction *t1,
 					  struct binder_transaction *t2)
 {
+#ifdef CONFIG_REKERNEL
+	if ((t1->flags & t2->flags & TF_ONE_WAY) != TF_ONE_WAY || !t1->to_proc || !t2->to_proc)
+#else
 	if ((t1->flags & t2->flags & (TF_ONE_WAY | TF_UPDATE_TXN)) !=
 	    (TF_ONE_WAY | TF_UPDATE_TXN) || !t1->to_proc || !t2->to_proc)
+#endif /* CONFIG_REKERNEL */
 		return false;
 	if (t1->to_proc->tsk == t2->to_proc->tsk && t1->code == t2->code &&
 	    t1->flags == t2->flags && t1->buffer->pid == t2->buffer->pid &&
@@ -3008,6 +3015,32 @@ binder_find_outdated_transaction_ilocked(struct binder_transaction *t,
 	return NULL;
 }
 
+#ifdef CONFIG_REKERNEL
+void rekernel_binder_transaction(bool reply, struct binder_transaction *t,
+			struct binder_node *target_node, struct binder_transaction_data *tr) {
+	struct binder_proc *to_proc;
+	struct binder_alloc *target_alloc;
+	if (!t->to_proc)
+		return;
+	to_proc = t->to_proc;
+
+	if (reply) {
+		binder_reply_handler(task_tgid_nr(current), current, to_proc->pid, to_proc->tsk, false, tr);
+	} else if (t->from) {
+		if (t->from->proc) {
+			binder_trans_handler(t->from->proc->pid, t->from->proc->tsk, to_proc->pid, to_proc->tsk, false, tr);
+		}
+	} else { // oneway=1
+		binder_trans_handler(task_tgid_nr(current), current, to_proc->pid, to_proc->tsk, true, tr);
+
+		target_alloc = &to_proc->alloc;
+		if (target_alloc->free_async_space < (target_alloc->buffer_size / 10 + 0x300)) {
+			binder_overflow_handler(task_tgid_nr(current), current, to_proc->pid, to_proc->tsk, true, tr);
+		}
+	}
+}
+#endif /* CONFIG_REKERNEL */
+
 /**
  * binder_proc_transaction() - sends a transaction to a process and wakes it up
  * @t:		transaction to send
@@ -3609,6 +3642,9 @@ static void binder_transaction(struct binder_proc *proc,
 		}
 	}
 
+#ifdef CONFIG_REKERNEL
+	rekernel_binder_transaction(reply, t, target_node, tr);
+#endif /* CONFIG_REKERNEL */
 	trace_binder_transaction(reply, t, target_node);
 
 	t->buffer = binder_alloc_new_buf(&target_proc->alloc, tr->data_size,
diff --git a/drivers/rekernel/Kconfig b/drivers/rekernel/Kconfig
new file mode 100644
index 000000000..d60047760
--- /dev/null
+++ b/drivers/rekernel/Kconfig
@@ -0,0 +1,15 @@
+menu "Re:Kernel"
+
+config REKERNEL
+	bool "Re:Kernel support"
+	default y
+	help
+	  Make tombstone users get a better experience.
+
+config REKERNEL_NETWORK
+	bool "Re:Kernel NetReceive unfreeze support"
+    depends on REKERNEL
+	default n
+	help
+	  Make tombstone users get a better experience.
+endmenu
diff --git a/drivers/rekernel/Makefile b/drivers/rekernel/Makefile
new file mode 100644
index 000000000..bb613644a
--- /dev/null
+++ b/drivers/rekernel/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_REKERNEL) += rekernel.o
diff --git a/drivers/rekernel/rekernel.c b/drivers/rekernel/rekernel.c
new file mode 100644
index 000000000..d2f98cdd5
--- /dev/null
+++ b/drivers/rekernel/rekernel.c
@@ -0,0 +1,317 @@
+#include <linux/init.h>
+#include <linux/types.h>
+
+#include <net/sock.h>
+#include <net/ip.h>
+#if IS_ENABLED(CONFIG_IPV6)
+#include <net/ipv6.h>
+#endif /* IS_ENABLED(CONFIG_IPV6) */
+#include <linux/netlink.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#if IS_ENABLED(CONFIG_IPV6)
+#include <linux/netfilter_ipv6.h>
+#endif /* IS_ENABLED(CONFIG_IPV6) */
+
+#include <linux/proc_fs.h>
+#include <uapi/linux/android/binder.h>
+#include "rekernel.h"
+
+#define MIN_USERAPP_UID				10000
+#define MAX_SYSTEM_UID				2000
+#define SYSTEM_APP_UID				1000
+#define INTERFACETOKEN_BUFF_SIZE	140
+#define PARCEL_OFFSET				16
+#define LINE_ERROR					1
+#define LINE_SUCCESS				0
+
+#define NETLINK_REKERNEL_MAX		26
+#define NETLINK_REKERNEL_MIN		22
+#define USER_PORT					100
+#define PACKET_SIZE					256
+
+static const char* binder_type[] = {
+	"reply",
+	"transaction",
+	"free_buffer_full",
+};
+static const char* rpc_type[] = {
+	"SYNC_BINDER_REPLY",
+	"SYNC_BINDER",
+	"FREE_BUFFER_FULL",
+};
+static int netlink_count = 0;
+static struct sock* netlink_socket;
+extern struct net init_net;
+static unsigned long netlink_unit = 0;
+
+static int sendMessage(char* packet_buffer, uint16_t len) {
+	struct sk_buff* socket_buffer;
+	struct nlmsghdr* netlink_hdr;
+
+	socket_buffer = nlmsg_new(len, GFP_ATOMIC);
+	if (!socket_buffer) {
+		pr_err("netlink alloc failure.\n");
+		return -LINE_ERROR;
+	}
+
+	netlink_hdr = nlmsg_put(socket_buffer, 0, 0, netlink_unit, len, 0);
+	if (!netlink_hdr) {
+		pr_err("nlmsg_put failaure.\n");
+		nlmsg_free(socket_buffer);
+		return -LINE_ERROR;
+	}
+
+	memcpy(nlmsg_data(netlink_hdr), packet_buffer, len);
+	return netlink_unicast(netlink_socket, socket_buffer, USER_PORT, MSG_DONTWAIT);
+}
+// Test code, Useless
+static void netlink_rcv_msg(struct sk_buff* socket_buffer) {
+	struct nlmsghdr* nlhdr = NULL;
+	char* umsg = NULL;
+	char* kmsg;
+	char netlink_kmsg[PACKET_SIZE];
+
+	if (socket_buffer->len >= nlmsg_total_size(0)) {
+		netlink_count++;
+		snprintf(netlink_kmsg, sizeof(netlink_kmsg), "Successfully received data packet! %d", netlink_count);
+		kmsg = netlink_kmsg;
+		nlhdr = nlmsg_hdr(socket_buffer);
+		umsg = NLMSG_DATA(nlhdr);
+		if (umsg) {
+			printk("kernel recv packet from user: %s\n", umsg);
+			sendMessage(kmsg, strlen(kmsg));
+		}
+	}
+}
+#ifdef CONFIG_REKERNEL_NETWORK
+static unsigned int rekernel_pkg_ipv4_ipv6_in(void* priv, struct sk_buff* socket_buffer,
+	const struct nf_hook_state* state) {
+	struct sock* sk;
+	unsigned int thoff = 0;
+	unsigned short frag_off = 0;
+	uid_t uid;
+	uint hook;
+	struct net_device* dev = NULL;
+
+	if (!socket_buffer || !socket_buffer->len || !state)
+		return NF_ACCEPT;
+
+	hook = state->hook;
+	if (NF_INET_LOCAL_IN == hook)
+		dev = state->in;
+
+	if (NULL == dev)
+		return NF_ACCEPT;
+
+	if (ip_hdr(socket_buffer)->version == 4) {
+		if (ip_hdr(socket_buffer)->protocol != IPPROTO_TCP)
+			return NF_ACCEPT;
+#if IS_ENABLED(CONFIG_IPV6)
+	} else if (ip_hdr(socket_buffer)->version == 6) {
+		if (ipv6_find_hdr(socket_buffer, &thoff, -1, &frag_off, NULL) != IPPROTO_TCP)
+			return NF_ACCEPT;
+#endif
+	} else {
+		return NF_ACCEPT;
+	}
+
+	sk = skb_to_full_sk(socket_buffer);
+	if (sk == NULL || !sk_fullsock(sk))
+		return NF_ACCEPT;
+
+	uid = sock_i_uid(sk).val;
+	if (uid < MIN_USERAPP_UID)
+		return NF_ACCEPT;
+
+	rekernel_report(NETWORK, 0, ip_hdr(socket_buffer)->version, NULL, uid, NULL, true, NULL);
+	return NF_ACCEPT;
+}
+/* Only monitor input network packages */
+static struct nf_hook_ops rekernel_nf_ops[] = {
+	{
+		.hook = rekernel_pkg_ipv4_ipv6_in,
+		.pf = NFPROTO_IPV4,
+		.hooknum = NF_INET_LOCAL_IN,
+		.priority = NF_IP_PRI_SELINUX_LAST + 1,
+	},
+#if IS_ENABLED(CONFIG_IPV6)
+	{
+		.hook = rekernel_pkg_ipv4_ipv6_in,
+		.pf = NFPROTO_IPV6,
+		.hooknum = NF_INET_LOCAL_IN,
+		.priority = NF_IP6_PRI_SELINUX_LAST + 1,
+	}
+#endif
+};
+
+int register_netfilter(void) {
+	int rc;
+	struct net* net = NULL;
+	for_each_net(net) {
+		rc = nf_register_net_hooks(net, rekernel_nf_ops, ARRAY_SIZE(rekernel_nf_ops));
+		if (rc) {
+			pr_err("register netfilter hooks failed, rc=%d\n", rc);
+			break;
+		}
+	}
+	if (rc) {
+		for_each_net(net) {
+			nf_unregister_net_hooks(net, rekernel_nf_ops, ARRAY_SIZE(rekernel_nf_ops));
+		}
+		return -1;
+	}
+
+	return LINE_SUCCESS;
+}
+#endif /* CONFIG_REKERNEL_NETWORK */
+struct netlink_kernel_cfg cfg = {
+	.input = netlink_rcv_msg, // set recv callback
+};
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry* rekernel_dir, * rekernel_unit_entry;
+static int rekernel_unit_show(struct seq_file* m, void* v) {
+	seq_printf(m, "%lu\n", netlink_unit);
+	return LINE_SUCCESS;
+}
+static int rekernel_unit_open(struct inode* inode, struct file* file) {
+	return single_open(file, rekernel_unit_show, NULL);
+}
+static const struct proc_ops rekernel_unit_fops = {
+	.proc_open = rekernel_unit_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release
+};
+#endif /* CONFIG_PROC_FS */
+// init
+static int start_rekernel(void) {
+	if (netlink_unit)
+		return 0;
+
+	pr_info("Thank you for choosing Re:Kernel!\n");
+#ifdef CONFIG_REKERNEL_NETWORK
+	pr_info("NetFilter is enabled!\n");
+#endif
+	pr_info("Re:Kernel v8.0 | DEVELOPER: Sakion Team | Timeline | USER PORT: %d\n", USER_PORT);
+	pr_info("Trying to create Re:Kernel Server......\n");
+
+	for (netlink_unit = NETLINK_REKERNEL_MIN; netlink_unit < NETLINK_REKERNEL_MAX; netlink_unit++) {
+		netlink_socket = netlink_kernel_create(&init_net, netlink_unit, &cfg);
+		if (netlink_socket != NULL)
+			break;
+	}
+	if (netlink_socket == NULL) {
+		netlink_unit = 0;
+		pr_err("Failed to create Re:Kernel server!\n");
+		return -LINE_ERROR;
+	}
+	printk("Created Re:Kernel server! NETLINK UNIT: %lu\n", netlink_unit);
+
+#ifdef CONFIG_PROC_FS
+	rekernel_dir = proc_mkdir("rekernel", NULL);
+	if (!rekernel_dir) {
+		pr_err("create /proc/rekernel failed!\n");
+	} else {
+		char buff[32];
+		sprintf(buff, "%lu", netlink_unit);
+		rekernel_unit_entry = proc_create(buff, 0644, rekernel_dir, &rekernel_unit_fops);
+		if (!rekernel_unit_entry) {
+			pr_err("create rekernel unit failed!\n");
+		}
+	}
+#endif /* CONFIG_PROC_FS */
+#ifdef CONFIG_REKERNEL_NETWORK
+	if (register_netfilter()) {
+		pr_err("%s: Failed to hook netfilter!\n", __func__);
+		return -LINE_ERROR;
+	}
+#endif /* CONFIG_REKERNEL_NETWORK */
+	return LINE_SUCCESS;
+}
+
+void rekernel_report(int reporttype, int type, pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst, bool oneway, struct binder_transaction_data* tr) {
+	char binder_kmsg[PACKET_SIZE];
+	char buf_data[INTERFACETOKEN_BUFF_SIZE];
+	size_t buf_data_size;
+	char buf[INTERFACETOKEN_BUFF_SIZE] = { 0 };
+	char* p;
+	int i = 0;
+	int j = 0;
+
+	if (start_rekernel())
+		return;
+
+#ifdef CONFIG_REKERNEL_NETWORK
+	if (reporttype == NETWORK) {
+		char binder_kmsg[PACKET_SIZE];
+		snprintf(binder_kmsg, sizeof(binder_kmsg), "type=Network,target=%d,proto=ipv%d;", dst_pid, src_pid);
+		sendMessage(binder_kmsg, strlen(binder_kmsg));
+		return;
+	}
+#endif /* CONFIG_REKERNEL_NETWORK */
+
+	if (!frozen_task_group(dst))
+		return;
+
+	if (task_uid(src).val == task_uid(dst).val)
+		return;
+
+	switch (reporttype) {
+	case BINDER:
+		if (oneway && type == TRANSACTION) {
+			if (tr->code < 29 || tr->code > 32)
+				return;
+			buf_data_size = tr->data_size > INTERFACETOKEN_BUFF_SIZE ? INTERFACETOKEN_BUFF_SIZE : tr->data_size;
+			if (copy_from_user(buf_data, (char*)tr->data.ptr.buffer, buf_data_size))
+				return;
+			j = PARCEL_OFFSET + 1;
+			p = (char*)(buf_data)+PARCEL_OFFSET;
+			while (i < INTERFACETOKEN_BUFF_SIZE && j < buf_data_size && *p != '\0') {
+				buf[i++] = *p;
+				j += 2;
+				p += 2;
+			}
+			if (i == INTERFACETOKEN_BUFF_SIZE) {
+				buf[i - 1] = '\0';
+			}
+			snprintf(binder_kmsg, sizeof(binder_kmsg), "type=Binder,bindertype=%s,oneway=%d,from_pid=%d,from=%d,target_pid=%d,target=%d,rpc_name=%s,code=%d;", binder_type[type], oneway, src_pid, task_uid(src).val, dst_pid, task_uid(dst).val, buf, tr->code);
+		} else {
+			snprintf(binder_kmsg, sizeof(binder_kmsg), "type=Binder,bindertype=%s,oneway=%d,from_pid=%d,from=%d,target_pid=%d,target=%d,rpc_type=%s;", binder_type[type], oneway, src_pid, task_uid(src).val, dst_pid, task_uid(dst).val, rpc_type[type]);
+		}
+		break;
+	case SIGNAL:
+		snprintf(binder_kmsg, sizeof(binder_kmsg), "type=Signal,signal=%d,killer_pid=%d,killer=%d,dst_pid=%d,dst=%d;", type, src_pid, task_uid(src).val, dst_pid, task_uid(dst).val);
+		break;
+	default:
+		return;
+	}
+	sendMessage(binder_kmsg, strlen(binder_kmsg));
+}
+
+void binder_reply_handler(pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst, bool oneway, struct binder_transaction_data* tr) {
+	if (unlikely(!dst))
+		return;
+	if (task_uid(dst).val > MAX_SYSTEM_UID || src_pid == dst_pid)
+		return;
+
+	// oneway=0
+	rekernel_report(BINDER, REPLY, src_pid, src, dst_pid, dst, oneway, tr);
+}
+
+void binder_trans_handler(pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst, bool oneway, struct binder_transaction_data* tr) {
+	if (unlikely(!dst))
+		return;
+	if ((task_uid(dst).val <= MIN_USERAPP_UID) || src_pid == dst_pid)
+		return;
+
+	rekernel_report(BINDER, TRANSACTION, src_pid, src, dst_pid, dst, oneway, tr);
+}
+
+void binder_overflow_handler(pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst, bool oneway, struct binder_transaction_data* tr) {
+	if (unlikely(!dst))
+		return;
+
+	// oneway=1
+	rekernel_report(BINDER, OVERFLOW, src_pid, src, dst_pid, dst, oneway, tr);
+}
diff --git a/drivers/rekernel/rekernel.h b/drivers/rekernel/rekernel.h
new file mode 100644
index 000000000..af7022a85
--- /dev/null
+++ b/drivers/rekernel/rekernel.h
@@ -0,0 +1,34 @@
+#ifndef __REKERNEL_H
+#define __REKERNEL_H
+
+#include <linux/types.h>
+#include <linux/cgroup.h>
+#include <linux/freezer.h>
+#include <uapi/linux/android/binder.h>
+
+enum report_type {
+	BINDER,
+	SIGNAL,
+#ifdef CONFIG_REKERNEL_NETWORK
+	NETWORK,
+#endif /* CONFIG_REKERNEL_NETWORK */
+};
+enum binder_type {
+	REPLY,
+	TRANSACTION,
+	OVERFLOW,
+};
+
+static inline bool jobctl_frozen(struct task_struct* task) {
+	return ((task->jobctl & JOBCTL_TRAP_FREEZE) != 0);
+}
+static inline bool frozen_task_group(struct task_struct* task) {
+	return (jobctl_frozen(task) || cgroup_freezing(task));
+}
+
+extern void rekernel_report(int reporttype, int type, pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst, bool oneway, struct binder_transaction_data* tr);
+extern void binder_reply_handler(pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst, bool oneway, struct binder_transaction_data* tr);
+extern void binder_trans_handler(pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst, bool oneway, struct binder_transaction_data* tr);
+extern void binder_overflow_handler(pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst, bool oneway, struct binder_transaction_data* tr);
+
+#endif /* __REKERNEL_H */
diff --git a/kernel/signal.c b/kernel/signal.c
index 27cb9b54e..467924a6a 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -57,6 +57,10 @@
 #include <asm/unistd.h>
 #include <asm/siginfo.h>
 #include <asm/cacheflush.h>
+#ifdef CONFIG_REKERNEL
+#include <uapi/asm/signal.h>
+#include <../drivers/rekernel/rekernel.h>
+#endif /* CONFIG_REKERNEL */
 #include <asm/syscall.h>	/* for syscall_get_* */
 
 #ifdef CONFIG_SAMSUNG_FREECESS
@@ -1321,6 +1325,10 @@ int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p
 {
 	unsigned long flags;
 	int ret = -ESRCH;
+#ifdef CONFIG_REKERNEL
+	if (sig == SIGKILL || sig == SIGTERM || sig == SIGABRT || sig == SIGQUIT)
+		rekernel_report(SIGNAL, sig, task_tgid_nr(current), current, task_tgid_nr(p), p, false, NULL);
+#endif /* CONFIG_REKERNEL */
 	trace_android_vh_do_send_sig_info(sig, current, p);
 
 #ifdef CONFIG_SAMSUNG_FREECESS
